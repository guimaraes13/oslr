/*
 * Online Structure Learner by Revision (OSLR) is an online relational
 * learning algorithm that can handle continuous, open-ended
 * streams of relational examples as they arrive. We employ
 * techniques from theory revision to take advantage of the already
 * acquired knowledge as a starting point, find where it should be
 * modified to cope with the new examples, and automatically update it.
 * We rely on the Hoeffding's bound statistical theory to decide if the
 * model must in fact be updated accordingly to the new examples.
 * The system is built upon ProPPR statistical relational language to
 * describe the induced models, aiming at contemplating the uncertainty
 * inherent to real data.
 *
 * Copyright (C) 2017-2018 Victor Guimarães
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* KnowledgeParser.java */
/* Generated By:JavaCC: Do not edit this line. KnowledgeParser.java */


package br.ufrj.cos.logic.parser.knowledge;

import br.ufrj.cos.logic.*;
import br.ufrj.cos.util.AtomFactory;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.script.ScriptException;
import java.io.InputStream;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.util.*;

import static br.ufrj.cos.util.log.ParsingLog.ERROR_PARSING_LINE;

/**
 * Created on 15/04/17.
 *
 * @author Victor Guimarães
 */
public class KnowledgeParser implements Iterable<Clause>, Iterator<Clause>, KnowledgeParserConstants {

    /**
     * The logger
     */
    public static final Logger logger = LogManager.getLogger();

    public AtomFactory factory = new AtomFactory();
    protected boolean hasNext = true;
    private static int[] jj_la1_0;

    static {
        jj_la1_init_0();
    }

    @Override
    public Clause next() {
        Clause clause = null;
        try {
            clause = readLine();
        } catch (ParseException e) {
            logger.error(ERROR_PARSING_LINE, e);
        }
        return clause;
    }

    private final int[] jj_la1 = new int[19];
    private final List<int[]> jj_expentries = new ArrayList<int[]>();
    private final int trace_indent = 0;
    /**
     * Generated Token Manager.
     */
    public KnowledgeParserTokenManager token_source;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    protected Map variableMap = new HashMap();
    SimpleCharStream jj_input_stream;
    private int jj_ntk;
    private int jj_gen;
    private int[] jj_expentry;
    private int jj_kind = -1;
    private boolean trace_enabled;

    /**
     * Constructor with InputStream.
     */
    public KnowledgeParser(InputStream stream) {
        this(stream, null);
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public KnowledgeParser(InputStream stream, String encoding) {
        try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new KnowledgeParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++) { jj_la1[i] = -1; }
    }

    /**
     * Constructor.
     */
    public KnowledgeParser(Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new KnowledgeParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++) { jj_la1[i] = -1; }
    }

    /**
     * Constructor with generated Token Manager.
     */
    public KnowledgeParser(KnowledgeParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++) { jj_la1[i] = -1; }
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0x1004c0, 0x1004c0, 0x1, 0x1, 0xc0, 0x2000, 0x500, 0x2000, 0x4c0, 0x8000, 0x60000,
                0x100400, 0xc0, 0x2000, 0x800, 0xc0, 0x200600,0x200400,0x100,};
    }

    @Override
    public boolean hasNext() {
        return hasNext;
    }

    @Override
    public Iterator<Clause> iterator() {
        return this; }

    public final List parseKnowledge() throws ParseException {
        Clause clause;
        List clauses;
        clauses = new ArrayList();
        label_1:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case DECIMAL:
                case INTEGER:
                case CONSTANT:
                case FUNCTION_DEFINITION_SIGN: {
                    break;
                }
                default:
                    jj_la1[0] = jj_gen;
                    break label_1;
            }
            clause = readKnowledgeLine();
            clauses.add(clause);
        }
        jj_consume_token(0);
        {if ("" != null) { return clauses; }}
        throw new Error("Missing return statement in function");
    }

    public final Collection parseKnowledgeAppend(Collection clauses) throws ParseException {
        Clause clause;
        label_2:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case DECIMAL:
                case INTEGER:
                case CONSTANT:
                case FUNCTION_DEFINITION_SIGN: {
                    break;
                }
                default:
                    jj_la1[1] = jj_gen;
                    break label_2;
            }
            clause = readKnowledgeLine();
            clauses.add(clause);
        }
        jj_consume_token(0);
        {if ("" != null) { return clauses; }}
        throw new Error("Missing return statement in function");
    }

    public final Clause readLine() throws ParseException {
        Clause clause;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 0: {
                readHasNext();
                if (!hasNext) {if ("" != null) { return null; }}
                break;
            }
            default:
                jj_la1[2] = jj_gen;
        }
        clause = readKnowledgeLine();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 0: {
                jj_consume_token(0);
                hasNext = false;
                break;
            }
            default:
                jj_la1[3] = jj_gen;
        }
        {if ("" != null) { return clause; }}
        throw new Error("Missing return statement in function");
    }

    protected final Clause readKnowledgeLine() throws ParseException {Clause clause = null;

        boolean weighted = false;
        double weight = -1;

        Atom atom;
        List body;

        // boolean featured = false;
        List features = null;
//	Map variableMap;

        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case DECIMAL:
            case INTEGER: {
                weight = readDecimal();
                jj_consume_token(WEIGHT_SEPARATOR);
                weighted = true;
                break;
            }
            default:
                jj_la1[4] = jj_gen;
        }
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case CONSTANT: {
                atom = readAtom(variableMap);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case END_OF_LINE_CHARACTER:{
                        jj_consume_token(END_OF_LINE_CHARACTER);
if (weighted) {
    atom = new WeightedAtom(weight, atom);
}
                        clause = atom;
                        break;
                    }
                    case IMPLICATION_SIGN: {
                        jj_consume_token(IMPLICATION_SIGN);
                        body = new ArrayList();
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                            case NEGATION:
                            case CONSTANT: {
                                readLiteral(body, variableMap);
                                label_3:
                                while (true) {
                                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                                        case LIST_SEPARATOR: {
                                            break;
                                        }
                                        default:
                                            jj_la1[5] = jj_gen;
                                            break label_3;
                                    }
                                    jj_consume_token(LIST_SEPARATOR);
                                    readLiteral(body, variableMap);
                                }
                                break;
                            }
                            default:
                                jj_la1[6] = jj_gen;
                        }
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                            case OPEN_FEATURES: {
                                jj_consume_token(OPEN_FEATURES);
                                features = new ArrayList();
                                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                                    case DECIMAL:
                                    case INTEGER:
                                    case CONSTANT: {
                                        readFeature(features, variableMap);
                                        label_4:
                                        while (true) {
                                            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                                                case LIST_SEPARATOR: {
                                                    break;
                                                }
                                                default:
                                                    jj_la1[7] = jj_gen;
                                                    break label_4;
                                            }
                                            jj_consume_token(LIST_SEPARATOR);
                                            readFeature(features, variableMap);
                                        }
                                        break;
                                    }
                                    default:
                                        jj_la1[8] = jj_gen;
                                }
                                jj_consume_token(CLOSE_FEATURES);
                                break;
                            }
                            default:
                                jj_la1[9] = jj_gen;
                        }
                        jj_consume_token(END_OF_LINE_CHARACTER);
if (features != null) {
    clause = new FeaturedClause(atom, new Conjunction(body), new Features(features));
} else if (weighted) {
    clause = new WeightedClause(weight, atom, new Conjunction(body));
} else {
    clause = new HornClause(atom, new Conjunction(body));
}
                        break;
                    }
                    default:
                        jj_la1[10] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            }
            case FUNCTION_DEFINITION_SIGN: {
                jj_consume_token(FUNCTION_DEFINITION_SIGN);
                clause = readFunction();
                break;
            }
            default:
                jj_la1[11] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {if ("" != null) { return clause; }}
        throw new Error("Missing return statement in function");
    }

    public final FunctionalSymbol readFunction() throws ParseException {
        String predicate;
        Token arityToken;
        Token function;
        int arity;
        predicate = readPredicate();
        jj_consume_token(ARITY_SEPARATOR_CHARACTER);
        arityToken = jj_consume_token(INTEGER);
        arity = Integer.parseInt(arityToken.image);
        jj_consume_token(IMPLICATION_SIGN);
        function = jj_consume_token(QUOTED);
        function.image = function.image.substring(1, function.image.length() - 1);
        jj_consume_token(END_OF_LINE_CHARACTER);
        try {
            {if ("" != null) { return new FunctionalSymbol(new Predicate(predicate, arity), function.image); }}
        } catch (ScriptException e) {
            {if (true) { throw new ParseException("Bad formatted function:\t" + e.getMessage()); }}
        }
        throw new Error("Missing return statement in function");
    }

    public final boolean readHasNext() throws ParseException {
        jj_consume_token(0);
        hasNext = false;
        {if ("" != null) { return hasNext; }}
        throw new Error("Missing return statement in function");
    }

    public final double readDecimal() throws ParseException {
        Token decimal;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case DECIMAL: {
                decimal = jj_consume_token(DECIMAL);
                break;
            }
            case INTEGER: {
                decimal = jj_consume_token(INTEGER);
                break;
            }
            default:
                jj_la1[12] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {if ("" != null) { return Double.parseDouble(decimal.image); }}
        throw new Error("Missing return statement in function");
    }

    public final Atom readAtom(Map variableMap) throws ParseException {
        String predicate;
        List terms = new ArrayList();
        predicate = readPredicate();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case OPEN_PREDICATE_ARGUMENT: {
                jj_consume_token(OPEN_PREDICATE_ARGUMENT);
                readTerm(terms, variableMap);
                label_5:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case LIST_SEPARATOR: {
                            break;
                        }
                        default:
                            jj_la1[13] = jj_gen;
                            break label_5;
                    }
                    jj_consume_token(LIST_SEPARATOR);
                    readTerm(terms, variableMap);
                }
                jj_consume_token(CLOSE_PREDICATE_ARGUMENT);
                break;
            }
            default:
                jj_la1[14] = jj_gen;
        }
        Predicate value = factory.getPredicate(predicate, terms.size());
        {if ("" != null) { return new Atom(value, terms); }}
        throw new Error("Missing return statement in function");
    }

    public final void readFeature(List features, Map variableMap) throws ParseException {
        boolean weighted = false;
        double weight = -1;
        Atom atom = null;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case DECIMAL:
            case INTEGER: {
                weight = readDecimal();
                jj_consume_token(WEIGHT_SEPARATOR);
                weighted = true;
                break;
            }
            default:
                jj_la1[15] = jj_gen;
        }
        atom = readAtom(variableMap);
        if (weighted) {
            atom = new WeightedAtom(weight, atom);
        }
        features.add(atom);
    }

    public final String readPredicate() throws ParseException {
        Token predicate;
        predicate = jj_consume_token(CONSTANT);
        {if ("" != null) { return predicate.image; }}
        throw new Error("Missing return statement in function");
    }

    public final void readTerm(List<Term> terms, Map variableMap) throws ParseException {
        Term term;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case CONSTANT:
            case QUOTED: {
                term = readConstant();
                terms.add(term);
                break;
            }
            case VARIABLE: {
                term = readVariable(variableMap);
                terms.add(term);
                break;
            }
            default:
                jj_la1[16] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public final Term readConstant() throws ParseException {
        Token constant;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case CONSTANT: {
                constant = jj_consume_token(CONSTANT);
                break;
            }
            case QUOTED: {
                constant = jj_consume_token(QUOTED);
                constant.image = constant.image.substring(1, constant.image.length() - 1);
                break;
            }
            default:
                jj_la1[17] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {if ("" != null) { return factory.getConstant(token.image); }}
        throw new Error("Missing return statement in function");
    }

    public final Term readVariable(Map variableMap) throws ParseException {
        Token variable;
        variable = jj_consume_token(VARIABLE);
        if (!variableMap.containsKey(variable.image)) {
            variableMap.put(variable.image, new Variable(variable.image));
        }

        {if ("" != null) { return (Variable) variableMap.get(variable.image); }}
        throw new Error("Missing return statement in function");
    }

    public final void readLiteral(List<Literal> literals, Map variableMap) throws ParseException {
        boolean negated = false;
        Atom atom;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case NEGATION: {
                jj_consume_token(NEGATION);
                negated = true;
                break;
            }
            default:
                jj_la1[18] = jj_gen;
        }
        atom = readAtom(variableMap);
        literals.add(new Literal(atom, negated));
    }

    /**
     * Reinitialise.
     */
    public void ReInit(InputStream stream) {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(InputStream stream, String encoding) {
        try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++) { jj_la1[i] = -1; }
    }

    /**
     * Reinitialise.
     */
    public void ReInit(Reader stream) {
        if (jj_input_stream == null) {
            jj_input_stream = new SimpleCharStream(stream, 1, 1);
        } else {
            jj_input_stream.ReInit(stream, 1, 1);
        }
        if (token_source == null) {
            token_source = new KnowledgeParserTokenManager(jj_input_stream);
        }

        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++) { jj_la1[i] = -1; }
    }

    /**
     * Reinitialise.
     */
    public void ReInit(KnowledgeParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++) { jj_la1[i] = -1; }
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) { token = token.next; } else {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    /**
     * Get the next Token.
     */
    public final Token getNextToken() {
        if (token.next != null) { token = token.next; } else { token = token.next = token_source.getNextToken(); }
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /**
     * Get the specific Token.
     */
    public final Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) { t = t.next; } else { t = t.next = token_source.getNextToken(); }
        }
        return t;
    }

    private int jj_ntk_f() {
        if ((jj_nt = token.next) == null) { return (jj_ntk = (token.next = token_source.getNextToken()).kind); } else {
            return (jj_ntk = jj_nt.kind);
        }
    }

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[22];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 19; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 22; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /**
     * Trace enabled.
     */
    public final boolean trace_enabled() {
        return trace_enabled;
    }

    /**
     * Enable tracing.
     */
    public final void enable_tracing() {
    }

    /** Disable tracing. */
    public final void disable_tracing() {
    }

}
